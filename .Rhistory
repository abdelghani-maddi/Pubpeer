<<<<<<< HEAD
family = binomial)
summary(modele_logit4)
# Remplacer les valeurs NA par 0 dans les colonnes spécifiées
cols_to_replace <- c("nb_com_before_retract", "nb_com_after_retract", "nb_comm")
bdd_regr[cols_to_replace][is.na(bdd_regr[cols_to_replace])] <- 0
modele_logit4 <- glm(is_retracted ~ nb_com_before_retract,
data = bdd_regr,
family = binomial)
summary(modele_logit4)
modele_logit4 <- glm(is_retracted ~ nb_com_before_retract + nb_com_after_retract,
data = bdd_regr,
family = binomial)
summary(modele_logit4)
View(bdd_regr)
View(count_data)
# Faire le match en fonction de la colonne "DOI_clean"
retraction_data <- merge(pub, pub_ret, by = "DOI_clean")
# Supprimer la colonne "DOI_clean" du dataframe fusionné
retraction_data$DOI_clean <- NULL
# Joindre les dataframes count_data et retraction_data par la colonne "publication"
merged_data <- left_join(count_data, retraction_data, by = "publication")
View(merged_data)
merged_data$nb_com_before_retract <- with(merged_data, ifelse(date_com < RetractionDate, nb_comm, 0))
merged_data$nb_com_after_retract <- with(merged_data, ifelse(date_com >= RetractionDate, nb_comm, 0))
View(merged_data)
View(bdd_regr)
View(count_data)
View(data_comm)
View(retract_data)
View(retraction_data)
View(count_data)
merged_data$nb_com_before_retract <- with(merged_data, ifelse(date_com < RetractionDate, nb_comm, 0))
merged_data$nb_com_after_retract <- with(merged_data, ifelse(date_com >= RetractionDate, nb_comm, 0))
retraction_data <- aggregate(cbind(nb_com_before_retract, nb_com_after_retract, nb_comm) ~ publication + ID_retractionwatch +
RetractionDate + OriginalPaperDate + Continent, data = merged_data, FUN = sum)
View(merged_data)
# Remplacer les NA de la colonne "nb_com_before_retract" par les valeurs correspondantes de la colonne "nb_comm"
# et remplacer les NA de la colonne "nb_com_after_retract" par 0
merged_data$nb_com_before_retract <- ifelse(is.na(merged_data$nb_com_before_retract),
merged_data$nb_comm,
merged_data$nb_com_before_retract)
merged_data$nb_com_after_retract <- ifelse(is.na(merged_data$nb_com_after_retract), 0, merged_data$nb_com_after_retract)
View(merged_data)
write.xlsx(merged_data, "~/Documents/Pubpeer Gender/retraction_data.xlsx")
View(merged_data)
retraction_data <- read_excel("~/Documents/Pubpeer Gender/retraction_data.xlsx") # voir au-dessus pour la procédure
retract_data <- retraction_data[,c(1,3,11,12)]
View(retract_data)
# Pivoter le type de collabe H-F pour n'analyse
bdd_regr <- pivot_wider(bdd_reg, names_from = Gtype2, values_from = Gtype2, values_fn = list(Gtype2 = function(x) 1),
values_fill = list(Gtype2 = 0))
# Pivoter la discipline pour n'analyse
bdd_regr <- pivot_wider(bdd_regr, names_from = disc, values_from = disc, values_fn = list(disc = function(x) 1),
values_fill = list(disc = 0))
bdd_regr <- left_join(bdd_regr, retract_data, by = "publication")
View(bdd_regr)
modele_logit4 <- glm(is_retracted ~ nb_com_before_retract,
data = bdd_regr,
family = binomial)
retraction_data <- aggregate(cbind(nb_com_before_retract, nb_com_after_retract, nb_comm) ~ publication + ID_retractionwatch +
RetractionDate + OriginalPaperDate + Continent, data = merged_data, FUN = sum)
View(retract_data)
View(merged_data)
retraction_data <- aggregate(cbind(nb_com_before_retract, nb_com_after_retract, nb_comm) ~ publication, data = merged_data, FUN = sum)
View(retraction_data)
# Utilisation de la fonction group_by() et summarize() pour faire la somme par groupe
sum_by_publication <- merged_data %>%
=======
# adding spanning header
modify_spanning_header(c("stat_1", "stat_2") ~ "**Is retracted**") %>%
add_p() %>%
separate_p_footnotes()
# Distribution of publications according to the type of men-women collaboration in the overall Pubpeer dataset and within the retracted publications
df_retract %>%
select(publication, Gtype2, is_retracted) %>%
unique() %>%
subset(., !is.na(Gtype2)) %>%
tbl_summary(
include = c(Gtype2, is_retracted),
by = is_retracted,
sort = list(everything() ~ "frequency"),
statistic = list(
all_continuous() ~ c("{N_obs}")
)
) %>%
add_overall()  %>%
# adding spanning header
modify_spanning_header(c("stat_1", "stat_2") ~ "**Is retracted**") %>%
add_p() %>%
separate_p_footnotes()
# Distribution of publications according to the type of men-women collaboration in the overall Pubpeer dataset and within the retracted publications
df_retract %>%
select(publication, Gtype2, is_retracted, disc) %>%
unique() %>%
subset(., !is.na(Gtype2) & !is.na(disc)) %>%
tbl_summary(
include = c(Gtype2, is_retracted),
by = is_retracted,
sort = list(everything() ~ "frequency"),
statistic = list(
all_continuous() ~ c("{N_obs}")
)
) %>%
add_overall()  %>%
# adding spanning header
modify_spanning_header(c("stat_1", "stat_2") ~ "**Is retracted**") %>%
add_p() %>%
separate_p_footnotes()
# Distribution of publications according to the type of men-women collaboration in the overall Pubpeer dataset and within the retracted publications
df_retract %>%
select(publication, Gtype2, is_retracted, disc) %>%
unique() %>%
subset(., !is.na(Gtype2) & !is.na(disc)) %>%
tbl_summary(
include = c(Gtype2, is_retracted),
by = is_retracted,
sort = list(everything() ~ "frequency"),
statistic = list(
all_continuous() ~ c("{N_obs}")
)
) %>%
add_overall()  %>%
# adding spanning header
modify_spanning_header(c("stat_1", "stat_2") ~ "**Is retracted**") %>%
add_p() %>%
separate_p_footnotes()
# Distribution of publications according to the type of men-women collaboration in the overall Pubpeer dataset and within the retracted publications
df_retract %>%
subset(., !is.na(Gtype2) & !is.na(disc)) %>%
select(publication, Gtype2, is_retracted) %>%
unique() %>%
tbl_summary(
include = c(Gtype2, is_retracted),
by = is_retracted,
sort = list(everything() ~ "frequency"),
statistic = list(
all_continuous() ~ c("{N_obs}")
)
) %>%
add_overall()  %>%
# adding spanning header
modify_spanning_header(c("stat_1", "stat_2") ~ "**Is retracted**") %>%
add_p() %>%
separate_p_footnotes()
# Distribution of publications according to the type of men-women collaboration in the overall Pubpeer dataset and within the retracted publications
df_retract %>%
subset(., !is.na(Gtype2)) %>% # & !is.na(disc)) %>%
select(publication, Gtype2, is_retracted) %>%
unique() %>%
tbl_summary(
include = c(Gtype2, is_retracted),
by = is_retracted,
sort = list(everything() ~ "frequency"),
statistic = list(
all_continuous() ~ c("{N_obs}")
)
) %>%
add_overall()  %>%
# adding spanning header
modify_spanning_header(c("stat_1", "stat_2") ~ "**Is retracted**") %>%
add_p() %>%
separate_p_footnotes()
t <- df_retract %>%
subset(., !is.na(Gtype2)) %>% # & !is.na(disc)) %>%
select(publication, Gtype2, is_retracted) %>%
unique()
n_distinct(t$publication)
rm(t)
# Distribution of publications according to the type of men-women collaboration in the overall Pubpeer dataset and within the retracted publications
df <- df_retract %>%
subset(., !is.na(Gtype2)) %>% # & !is.na(disc)) %>%
select(publication, Gtype2, is_retracted) %>%
unique()
# Calculate the total number of rows in the dataframe
total <- nrow(df)
# Create a table of counts for each "Gtype" value
table_all <- table(df$Gtype2)
# Create a table of counts for each "Gtype" value where "Retracted" is "True"
table_retracted <- table(df$Gtype2[df$is_retracted == 1])
# Calculate the relative proportion of each "Gtype" value in the entire dataframe
prop_all <- table_all / total
# Calculate the relative proportion of each "Gtype" value for "Retracted" = TRUE
prop_retracted <- table_retracted / sum(df$is_retracted == 1)
# Divide the relative proportions for "Retracted" = TRUE by those in the entire dataframe
relative_prop <- as.data.frame(prop_retracted / prop_all)
# Print the resulting table of relative proportions
relative_prop
## Représentation graphique
ggplot(relative_prop, aes(x = reorder(Var1, Freq), y = Freq)) +
geom_bar(stat = "identity") +
geom_col(fill = "#2C81C9") +
labs(
x = "Men-women collaboration type",
y = "% in retracted / % in overall"
) +
coord_flip() +
theme_light()
# Print the resulting table of relative proportions
relative_prop
# Print the resulting table of relative proportions
t <- as.data.frame(relative_prop)
View(t)
#write.xlsx(df_retract, "/Users/maddi/Documents/Pubpeer Gender/df_retract.xlsx")
reason_agr <- read_excel("~/Documents/Pubpeer Gender/reasons_retract aggreg.xlsx")
bdd_pub = read.csv2('/Users/maddi/Documents/Pubpeer project/Donnees/Bases PubPeer/PubPeer_Base publications.csv', sep=";")
# write.xlsx(freq_reasons, "/Users/maddi/Documents/Pubpeer Gender/reasons_retract_restreint.xlsx") # écrit directement sur le cloud
# recupérer les données après une aggrégation des raisons à la main
reason_agr <- read_excel("~/Documents/Pubpeer Gender/reasons_retract aggreg.xlsx")
View(reason_agr)
write.xlsx(reason_agr, "/Users/maddi/Documents/Pubpeer Gender/reasons_retract_restreint.xlsx")
# Matcher les raisons avec la bdd sur le gender
df_retract_reason <- df_retract_reason %>%
select(publication, Gtype2, ID_retractionwatch, Reason) %>%
unique()
## décortiquer les raisons
# éclater les raisons
df_retract_reason <- df_retract %>%
separate_rows(Reason, sep = ";")%>%
filter(Reason != "") %>%
mutate(Reason = str_replace(Reason, "\\+", ""))
# calcul de la fréquence
freq_reasons <- df_retract_reason %>%
select(publication, Reason) %>%
unique()
freq_reasons <- freq(freq_reasons$Reason) %>%
data_frame(rownames(.), .)
names(freq_reasons) = c("Reason","nb", "%", "val%")
# Matcher les raisons avec la bdd sur le gender
df_retract_reason <- df_retract_reason %>%
select(publication, Gtype2, ID_retractionwatch, Reason) %>%
unique()
# Merger les deux pour avoir les raisons aggrégées
df_retract_agr <- merge(df_retract_reason, reason_agr, by = "Reason")
# coocuurences des raisons (pour aider à l'interprétation)
# Calculer les co-occurrences des raisons
df_cooccurrences <- df_retract_agr %>%
select(publication, reason_aggreg) %>%
unique() %>%
inner_join(df_retract_agr, by = "publication") %>%
filter(reason_aggreg.x != reason_aggreg.y) %>%
group_by(reason_aggreg.x, reason_aggreg.y) %>%
summarise(nb_publication = n()) %>%
ungroup()
# Renommer les colonnes
colnames(df_cooccurrences) <- c("Reason_1", "Reason_2", "nb_publication")
View(df_cooccurrences)
df_retract_agr %>%
tbl_summary(
include = c(reason_aggreg, Gtype2),
by = Gtype2,
sort = list(everything() ~ "frequency"),
statistic = list(
all_continuous() ~ c("{N_obs}")
)
) %>%
add_overall(last = TRUE) #, col_label = "**Ensemble** (effectif total: {N})")
reason_agreg <- df_retract_agr %>%
select(reason_aggreg, Gtype2) %>%
table() %>%
data.frame()
View(reason_agreg)
View(reason_agr)
View(reason_agreg)
View(df_retract_agr)
df_reasons <- df_retract_reason %>%
select(publication, Reason, Gtype2) %>%
>>>>>>> c7416576a75b4badd60689b3e24130bae8f13e4c
group_by(publication) %>%
summarize(sum_nb_com_before_retract = sum(nb_com_before_retract, na.rm = TRUE),
sum_nb_com_after_retract = sum(nb_com_after_retract, na.rm = TRUE),
sum_nb_comm = sum(nb_comm, na.rm = TRUE))
View(sum_by_publication)
sum(sum_by_publication$sum_nb_comm)
View(df_retract)
View(df_gender)
View(bdd_pub)
# Utilisation de la fonction group_by() et summarize() pour faire la somme par groupe
retraction_data <- merged_data %>%
group_by(publication) %>%
<<<<<<< HEAD
summarize(sum_nb_com_before_retract = sum(nb_com_before_retract, na.rm = TRUE),
sum_nb_com_after_retract = sum(nb_com_after_retract, na.rm = TRUE),
sum_nb_comm = sum(nb_comm, na.rm = TRUE))
View(retraction_data)
write.xlsx(retraction_data, "~/Documents/Pubpeer Gender/retraction_data.xlsx")
View(retraction_data)
bdd_regr <- left_join(bdd_regr, retract_data, by = "publication")
View(bdd_regr)
# Pivoter le type de collabe H-F pour n'analyse
bdd_regr <- pivot_wider(bdd_reg, names_from = Gtype2, values_from = Gtype2, values_fn = list(Gtype2 = function(x) 1),
values_fill = list(Gtype2 = 0))
# Pivoter la discipline pour n'analyse
bdd_regr <- pivot_wider(bdd_regr, names_from = disc, values_from = disc, values_fn = list(disc = function(x) 1),
values_fill = list(disc = 0))
bdd_regr <- left_join(bdd_regr, retract_data, by = "publication")
View(bdd_regr)
# Pivoter le type de collabe H-F pour n'analyse
bdd_regr <- pivot_wider(bdd_reg, names_from = Gtype2, values_from = Gtype2, values_fn = list(Gtype2 = function(x) 1),
values_fill = list(Gtype2 = 0))
# Pivoter la discipline pour n'analyse
bdd_regr <- pivot_wider(bdd_regr, names_from = disc, values_from = disc, values_fn = list(disc = function(x) 1),
values_fill = list(disc = 0))
View(bdd_regr)
bdd_regr2 <- left_join(bdd_regr, retract_data, by = "publication")
View(bdd_regr2)
retraction_data <- read_excel("~/Documents/Pubpeer Gender/retraction_data.xlsx") # voir au-dessus pour la procédure
View(retraction_data)
# Pivoter le type de collabe H-F pour n'analyse
bdd_regr <- pivot_wider(bdd_reg, names_from = Gtype2, values_from = Gtype2, values_fn = list(Gtype2 = function(x) 1),
values_fill = list(Gtype2 = 0))
# Pivoter la discipline pour n'analyse
bdd_regr <- pivot_wider(bdd_regr, names_from = disc, values_from = disc, values_fn = list(disc = function(x) 1),
values_fill = list(disc = 0))
bdd_regr <- left_join(bdd_regr, retraction_data, by = "publication")
View(bdd_regr)
# Ajuster un modèle de régression logistique
modele_logit1 <- glm(is_retracted ~ `Collab. men-women m lead` + `Man alone` + `Collab. men only` + `Woman alone` + `Collab. men-women w lead` ,
data = bdd_regr,
family = binomial)
summary(modele_logit1)
## variables de controle
modele_logit2 <- glm(is_retracted ~ `Collab. men-women m lead` + `Man alone` + `Collab. men only` + `Woman alone` + `Collab. men-women w lead` +
log(nb_aut)
,
data = bdd_regr,
family = binomial)
summary(modele_logit2)
## variables de controle
modele_logit2b<- glm(is_retracted ~ `Collab. men-women m lead` + `Man alone` + `Collab. men only` + `Woman alone` + `Collab. men-women w lead` +
log(nb_aut) +
is_oa
,
data = bdd_regr,
family = binomial)
summary(modele_logit2b)
## variables de controle : discipline
modele_logit3 <- glm(is_retracted ~ `Collab. men-women m lead` + `Man alone` + `Collab. men only` + `Woman alone` + `Collab. men-women w lead` +
log(nb_aut) +
is_oa +
bdd_regr$`Social Sciences` +
bdd_regr$`Physical Sciences` +
bdd_regr$Technology +
bdd_regr$`Arts Humanities`,
data = bdd_regr,
family = binomial)
summary(modele_logit3)
modele_logit4 <- glm(is_retracted ~ nb_com_before_retract,
data = bdd_regr,
family = binomial)
modele_logit4 <- glm(is_retracted ~ nb_com_before_retract,
data = bdd_regr,
family = binomial)
modele_logit4 <- glm(is_retracted ~ bdd_regr$sum_nb_com_before_retract,
data = bdd_regr,
family = binomial)
summary(modele_logit4)
modele_logit4 <- glm(is_retracted ~ `Collab. men-women m lead` + `Man alone` + `Collab. men only` + `Woman alone` + `Collab. men-women w lead` +
log(nb_aut) +
is_oa +
bdd_regr$`Social Sciences` +
bdd_regr$`Physical Sciences` +
bdd_regr$Technology +
bdd_regr$`Arts Humanities`+
bdd_regr$sum_nb_com_before_retract,
data = bdd_regr,
family = binomial)
summary(modele_logit4)
modele_logit4 <- glm(is_retracted ~ `Collab. men-women m lead` + `Man alone` + `Collab. men only` + `Woman alone` + `Collab. men-women w lead` +
log(nb_aut) +
is_oa +
bdd_regr$sum_nb_comm,
data = bdd_regr,
family = binomial)
modele_logit4 <- glm(is_retracted ~ `Collab. men-women m lead` + `Man alone` + `Collab. men only` + `Woman alone` + `Collab. men-women w lead` +
log(nb_aut) +
is_oa +
bdd_regr$sum_nb_com_before_retract,
data = bdd_regr,
family = binomial)
summary(modele_logit4)
modele_logit4 <- glm(is_retracted ~ `Collab. men-women m lead` + `Man alone` + `Collab. men only` + `Woman alone` + `Collab. men-women w lead` +
log(nb_aut) +
is_oa +
bdd_regr$sum_nb_com_before_retract +
bdd_regr$sum_nb_com_after_retract,
data = bdd_regr,
family = binomial)
modele_logit4 <- glm(is_retracted ~ `Collab. men-women m lead` + `Man alone` + `Collab. men only` + `Woman alone` + `Collab. men-women w lead` +
log(nb_aut) +
is_oa +
bdd_regr$sum_nb_com_after_retract,
data = bdd_regr,
family = binomial)
modele_logit4 <- glm(is_retracted ~ `Collab. men-women m lead` + `Man alone` + `Collab. men only` + `Woman alone` + `Collab. men-women w lead` +
log(nb_aut) +
is_oa +
bdd_regr$sum_nb_com_after_retract,
data = bdd_regr,
family = binomial)
modele_logit4 <- glm(is_retracted ~ `Collab. men-women m lead` + `Man alone` + `Collab. men only` + `Woman alone` + `Collab. men-women w lead` +
log(nb_aut) +
is_oa +
bdd_regr$sum_nb_com_before_retract,
data = bdd_regr,
family = binomial)
summary(modele_logit4)
modele_logit4 <- glm(is_retracted ~ `Collab. men-women m lead` + `Man alone` + `Collab. men only` + `Woman alone` + `Collab. men-women w lead` +
log(nb_aut) +
is_oa +
bdd_regr$sum_nb_com_before_retract +
bdd_regr$`Social Sciences` +
bdd_regr$`Physical Sciences`
,
data = bdd_regr,
family = binomial)
summary(modele_logit4)
modele_logit4 <- glm(is_retracted ~ `Collab. men-women m lead` + `Man alone` + `Collab. men only` + `Woman alone` + `Collab. men-women w lead` +
log(nb_aut) +
is_oa +
bdd_regr$sum_nb_com_before_retract +
bdd_regr$`Social Sciences` +
bdd_regr$`Physical Sciences` +
bdd_regr$Technology +
bdd_regr$`Arts Humanities`
,
data = bdd_regr,
family = binomial)
summary(modele_logit4)
# Calculer le coefficient de détermination R^2
R2 <- 1 - (modele_logit4$deviance / modele_logit3$null.deviance)
cat("R^2 : ", R2, "\n")
# Afficher l'AIC et le BIC du modèle
AIC(modele_logit4)
BIC(modele_logit4)
results <- broom::tidy(modele_logit4)
write.xlsx(results, "~/Documents/Pubpeer Gender/modele_logit4.xlsx")
## variables de controle : nombre de commentaires avant retractation
# Calculer les valeurs seuils pour les 5% des valeurs extrêmes de la variable "nb_comm"
lower_threshold <- quantile(bdd_regr$nb_comm, 0.05)
upper_threshold <- quantile(bdd_regr$nb_comm, 0.95)
# Appliquer le filtre pour supprimer les valeurs extrêmes
bdd_regr_filtered <- bdd_regr[bdd_regr$nb_comm >= lower_threshold & bdd_regr$nb_comm <= upper_threshold, ]
View(bdd_regr)
## variables de controle : nombre de commentaires avant retractation
# Calculer les valeurs seuils pour les 5% des valeurs extrêmes de la variable "nb_comm"
lower_threshold <- quantile(bdd_regr$nb_comm, 0.05)
## variables de controle : nombre de commentaires avant retractation
# Calculer les valeurs seuils pour les 5% des valeurs extrêmes de la variable "nb_comm"
lower_threshold <- quantile(bdd_regr$sum_nb_comm, 0.05)
upper_threshold <- quantile(bdd_regr$sum_nb_comm, 0.95)
# Appliquer le filtre pour supprimer les valeurs extrêmes
bdd_regr_filtered <- bdd_regr[bdd_regr$sum_nb_comm >= lower_threshold & bdd_regr$sum_nb_comm <= upper_threshold, ]
modele_logit4 <- glm(is_retracted ~ `Collab. men-women m lead` + `Man alone` + `Collab. men only` + `Woman alone` + `Collab. men-women w lead` +
log(nb_aut) +
is_oa +
bdd_regr$sum_nb_com_before_retract +
bdd_regr$`Social Sciences` +
bdd_regr$`Physical Sciences` +
bdd_regr$Technology +
bdd_regr$`Arts Humanities`
,
data = bdd_regr_filtered,
family = binomial)
modele_logit4 <- glm(is_retracted ~ `Collab. men-women m lead` + `Man alone` + `Collab. men only` + `Woman alone` + `Collab. men-women w lead` +
log(nb_aut) +
is_oa +
sum_nb_com_before_retract +
`Social Sciences` +
`Physical Sciences` +
Technology +
`Arts Humanities`
,
data = bdd_regr_filtered,
family = binomial)
summary(modele_logit4)
## variables de controle : nombre de commentaires avant retractation
# Calculer les valeurs seuils pour les 5% des valeurs extrêmes de la variable "nb_comm"
lower_threshold <- quantile(bdd_regr$sum_nb_comm, 0.01)
upper_threshold <- quantile(bdd_regr$sum_nb_comm, 0.99)
# Appliquer le filtre pour supprimer les valeurs extrêmes
bdd_regr_filtered <- bdd_regr[bdd_regr$sum_nb_comm >= lower_threshold & bdd_regr$sum_nb_comm <= upper_threshold, ]
modele_logit4 <- glm(is_retracted ~ `Collab. men-women m lead` + `Man alone` + `Collab. men only` + `Woman alone` + `Collab. men-women w lead` +
log(nb_aut) +
is_oa +
sum_nb_com_before_retract +
`Social Sciences` +
`Physical Sciences` +
Technology +
`Arts Humanities`
,
data = bdd_regr_filtered,
family = binomial)
summary(modele_logit4)
## variables de controle : nombre de commentaires avant retractation
# Calculer les valeurs seuils pour les 5% des valeurs extrêmes de la variable "nb_comm"
lower_threshold <- quantile(bdd_regr$sum_nb_comm, 0.00)
upper_threshold <- quantile(bdd_regr$sum_nb_comm, 0.99)
# Appliquer le filtre pour supprimer les valeurs extrêmes
bdd_regr_filtered <- bdd_regr[bdd_regr$sum_nb_comm >= lower_threshold & bdd_regr$sum_nb_comm <= upper_threshold, ]
modele_logit4 <- glm(is_retracted ~ `Collab. men-women m lead` + `Man alone` + `Collab. men only` + `Woman alone` + `Collab. men-women w lead` +
log(nb_aut) +
is_oa +
sum_nb_com_before_retract +
`Social Sciences` +
`Physical Sciences` +
Technology +
`Arts Humanities`
,
data = bdd_regr_filtered,
family = binomial)
summary(modele_logit4)
upper_threshold <- quantile(bdd_regr$sum_nb_comm, 0.90)
# Appliquer le filtre pour supprimer les valeurs extrêmes
bdd_regr_filtered <- bdd_regr[bdd_regr$sum_nb_comm >= lower_threshold & bdd_regr$sum_nb_comm <= upper_threshold, ]
modele_logit4 <- glm(is_retracted ~ `Collab. men-women m lead` + `Man alone` + `Collab. men only` + `Woman alone` + `Collab. men-women w lead` +
log(nb_aut) +
is_oa +
sum_nb_com_before_retract +
`Social Sciences` +
`Physical Sciences` +
Technology +
`Arts Humanities`
,
data = bdd_regr_filtered,
family = binomial)
summary(modele_logit4)
upper_threshold <- quantile(bdd_regr$sum_nb_comm, 1)
# Appliquer le filtre pour supprimer les valeurs extrêmes
bdd_regr_filtered <- bdd_regr[bdd_regr$sum_nb_comm >= lower_threshold & bdd_regr$sum_nb_comm <= upper_threshold, ]
modele_logit4 <- glm(is_retracted ~ `Collab. men-women m lead` + `Man alone` + `Collab. men only` + `Woman alone` + `Collab. men-women w lead` +
log(nb_aut) +
is_oa +
sum_nb_com_before_retract +
`Social Sciences` +
`Physical Sciences` +
Technology +
`Arts Humanities`
,
data = bdd_regr_filtered,
family = binomial)
summary(modele_logit4)
## variables de controle : nombre de commentaires avant retractation
# Calculer les valeurs seuils pour les 5% des valeurs extrêmes de la variable "nb_comm"
lower_threshold <- quantile(bdd_regr$sum_nb_comm, 0.00)
upper_threshold <- quantile(bdd_regr$sum_nb_comm, 0.95)
# Appliquer le filtre pour supprimer les valeurs extrêmes
bdd_regr_filtered <- bdd_regr[bdd_regr$sum_nb_comm >= lower_threshold & bdd_regr$sum_nb_comm <= upper_threshold, ]
modele_logit4 <- glm(is_retracted ~ `Collab. men-women m lead` + `Man alone` + `Collab. men only` + `Woman alone` + `Collab. men-women w lead` +
log(nb_aut) +
is_oa +
sum_nb_com_before_retract +
`Social Sciences` +
`Physical Sciences` +
Technology +
`Arts Humanities`
,
data = bdd_regr_filtered,
family = binomial)
summary(modele_logit4)
modele_logit4 <- glm(is_retracted ~ `Collab. men-women m lead` + `Man alone` + `Collab. men only` + `Woman alone` + `Collab. men-women w lead` +
log(nb_aut) +
is_oa +
sum_nb_com_after_retract +
`Social Sciences` +
`Physical Sciences` +
Technology +
`Arts Humanities`
,
data = bdd_regr_filtered,
family = binomial)
modele_logit4 <- glm(is_retracted ~ `Collab. men-women m lead` + `Man alone` + `Collab. men only` + `Woman alone` + `Collab. men-women w lead` +
log(nb_aut) +
is_oa +
sum_nb_com_befor_retract +
`Social Sciences` +
`Physical Sciences` +
Technology +
`Arts Humanities`
,
data = bdd_regr_filtered,
family = binomial)
modele_logit4 <- glm(is_retracted ~ `Collab. men-women m lead` + `Man alone` + `Collab. men only` + `Woman alone` + `Collab. men-women w lead` +
log(nb_aut) +
is_oa +
sum_nb_com_before_retract +
`Social Sciences` +
`Physical Sciences` +
Technology +
`Arts Humanities`
,
data = bdd_regr_filtered,
family = binomial)
summary(modele_logit4)
modele_logit4 <- glm(is_retracted ~ `Collab. men-women m lead` + `Man alone` + `Collab. men only` + `Woman alone` + `Collab. men-women w lead` +
log(nb_aut) +
is_oa +
#sum_nb_com_before_retract +
sum_nb_comm +
`Social Sciences` +
`Physical Sciences` +
Technology +
`Arts Humanities`
,
data = bdd_regr_filtered,
family = binomial)
summary(modele_logit4)
## variables de controle : nombre de commentaires avant retractation
# Calculer les valeurs seuils pour les 5% des valeurs extrêmes de la variable "nb_comm"
lower_threshold <- quantile(bdd_regr$sum_nb_comm, 0.05)
## variables de controle : nombre de commentaires avant retractation
# Calculer les valeurs seuils pour les 5% des valeurs extrêmes de la variable "nb_comm"
lower_threshold <- quantile(bdd_regr$sum_nb_comm, 0.05)
upper_threshold <- quantile(bdd_regr$sum_nb_comm, 0.95)
# Appliquer le filtre pour supprimer les valeurs extrêmes
bdd_regr_filtered <- bdd_regr[bdd_regr$sum_nb_comm >= lower_threshold & bdd_regr$sum_nb_comm <= upper_threshold, ]
modele_logit4 <- glm(is_retracted ~ `Collab. men-women m lead` + `Man alone` + `Collab. men only` + `Woman alone` + `Collab. men-women w lead` +
log(nb_aut) +
is_oa +
#sum_nb_com_before_retract +
sum_nb_comm +
`Social Sciences` +
`Physical Sciences` +
Technology +
`Arts Humanities`
,
data = bdd_regr_filtered,
family = binomial)
summary(modele_logit4)
## variables de controle : discipline
modele_logit3 <- glm(is_retracted ~ `Collab. men-women m lead` + `Man alone` + `Collab. men only` + `Woman alone` + `Collab. men-women w lead` +
log(nb_aut) +
is_oa +
bdd_regr$`Social Sciences` +
bdd_regr$`Physical Sciences` +
bdd_regr$Technology +
bdd_regr$`Arts Humanities`,
data = bdd_regr_filtered,
family = binomial)
summary(modele_logit3)
## variables de controle : discipline
modele_logit3 <- glm(is_retracted ~ `Collab. men-women m lead` + `Man alone` + `Collab. men only` + `Woman alone` + `Collab. men-women w lead` +
log(nb_aut) +
is_oa +
`Social Sciences` +
`Physical Sciences` +
Technology +
`Arts Humanities`,
data = bdd_regr_filtered,
family = binomial)
summary(modele_logit3)
## variables de controle : discipline
modele_logit3 <- glm(is_retracted ~ `Collab. men-women m lead` + `Man alone` + `Collab. men only` + `Woman alone` + `Collab. men-women w lead` +
log(nb_aut) +
is_oa +
`Social Sciences` +
`Physical Sciences` +
Technology +
`Arts Humanities`,
data = bdd_regr,
family = binomial)
summary(modele_logit3)
modele_logit4 <- glm(is_retracted ~ `Collab. men-women m lead` + `Man alone` + `Collab. men only` + `Woman alone` + `Collab. men-women w lead` +
log(nb_aut) +
is_oa +
#sum_nb_com_before_retract +
sum_nb_comm +
`Social Sciences` +
`Physical Sciences` +
Technology +
`Arts Humanities`
,
data = bdd_regr_filtered,
family = binomial)
summary(modele_logit4)
modele_logit4 <- glm(is_retracted ~ `Collab. men-women m lead` + `Man alone` + `Collab. men only` + `Woman alone` + `Collab. men-women w lead` +
log(nb_aut) +
is_oa +
#sum_nb_com_before_retract +
sum_nb_comm +
`Social Sciences` +
`Physical Sciences` +
Technology +
`Arts Humanities`
,
data = bdd_regr,
family = binomial)
summary(modele_logit4)
modele_logit4 <- glm(is_retracted ~ `Collab. men-women m lead` + `Man alone` + `Collab. men only` + `Woman alone` + `Collab. men-women w lead` +
log(nb_aut) +
is_oa +
#sum_nb_com_before_retract +
log(1+sum_nb_comm) +
`Social Sciences` +
`Physical Sciences` +
Technology +
`Arts Humanities`
,
data = bdd_regr,
family = binomial)
summary(modele_logit4)
modele_logit4 <- glm(is_retracted ~ `Collab. men-women m lead` + `Man alone` + `Collab. men only` + `Woman alone` + `Collab. men-women w lead` +
log(nb_aut) +
is_oa +
#sum_nb_com_before_retract +
log(sum_nb_comm) +
`Social Sciences` +
`Physical Sciences` +
Technology +
`Arts Humanities`
,
data = bdd_regr,
family = binomial)
=======
mutate(frac_reason = 1/n())
# sum en fonction de raison et gtype2
df_sum_reason <- df_reasons %>%
group_by(Reason, Gtype2) %>%
summarise(sum_frac_reason = sum(frac_reason))
sum(df_reasons$frac_reason)
View(df_sum_reason)
# sum en fonction de raison et gtype2
df_sum_reason <- df_reasons %>%
group_by(Reason, Gtype2) %>%
summarise(sum_frac_reason = sum(frac_reason), sum_reason = n_distinct(publication))
View(df_sum_reason)
View(df_reasons)
write.xlsx(df_sum_reason, "~/Documents/Pubpeer Gender/frac_raisons2.xlsx")
#####################################################################
### Analyse de données pour le papier collab h-f et retractations ###
#####################################################################
rm(list = ls()) #supprimer tous les objets
library(tidyverse)
library(questionr)
library(RPostgres)
library(gtsummary)
library(openxlsx2)
library(gender)
library(GenderInfer)
library(openxlsx)
library(readxl)
library(readxl)
raisons_ratio <- read_excel("~/Documents/Pubpeer Gender/`.xlsx")
View(raisons_ratio)
esquisse:::esquisser()
row.names(raisons_ratio) <- raisons_ratio$`Reasons (Retraction Watch)`
View(raisons_ratio)
raisons_ratio <- raisons_ratio[,-1]
View(raisons_ratio)
raisons_ratio <- read_excel("~/Documents/Pubpeer Gender/raisons_ratio.xlsx")
row.names(raisons_ratio) <- raisons_ratio$`Reasons (Retraction Watch)`
View(raisons_ratio)
raisons_ratio <- raisons_ratio %>%
subset(., select = .[,-1])
raisons_ratio <- raisons_ratio %>%
subset(., select = -`Reasons (Retraction Watch)`)
View(raisons_ratio)
raisons_ratio <- read_excel("~/Documents/Pubpeer Gender/raisons_ratio.xlsx")
row.names(raisons_ratio) <- raisons_ratio$`Reasons (Retraction Watch)`
df <- raisons_ratio %>%
subset(., select = -`Reasons (Retraction Watch)`)
raisons_ratio <- read_excel("~/Documents/Pubpeer Gender/raisons_ratio.xlsx")
row.names(raisons_ratio) <- raisons_ratio$`Reasons (Retraction Watch)`
df <- raisons_ratio %>%
select(-`Reasons (Retraction Watch)`)
View(df)
df <- raisons_ratio %>%
subset(., select = -`Reasons (Retraction Watch)`, drop = FALSE)
raisons_ratio <- read_excel("~/Documents/Pubpeer Gender/raisons_ratio.xlsx")
row.names(raisons_ratio) <- raisons_ratio$`Reasons (Retraction Watch)`
df <- raisons_ratio %>%
subset(., select = -`Reasons (Retraction Watch)`, drop = FALSE)
View(df)
row.names(df) <- raisons_ratio$`Reasons (Retraction Watch)`
View(df)
View(df)
# Créer la heatmap
heatmap_plot <- ggplot(data = df, aes(x = factor(rownames(df)), y = factor(colnames(df)))) +
geom_tile(aes(fill = df), color = "white") +
scale_fill_gradient(low = "blue", high = "red") +  # Choix des couleurs (ici, utilise une échelle de couleurs)
labs(x = "Colonnes", y = "Lignes", fill = "Valeurs") +  # Étiquettes des axes et de la légende
theme_minimal() +  # Style du thème (vous pouvez choisir un autre style si vous préférez)
theme(axis.text.x = element_text(angle = 45, hjust = 1))  # Inclinaison du texte de l'axe des x pour une meilleure lisibilité
print(heatmap_plot)
# Créer la heatmap
heatmap_plot <- ggplot(data = df, aes(x = factor(rownames(df)), y = factor(colnames(df)))) +
geom_tile(aes(fill = df), color = "white") +
scale_fill_gradient(low = "blue", high = "red") +  # Choix des couleurs (ici, utilise une échelle de couleurs)
labs(x = "Colonnes", y = "Lignes", fill = "Valeurs") +  # Étiquettes des axes et de la légende
theme_minimal() +  # Style du thème (vous pouvez choisir un autre style si vous préférez)
theme(axis.text.x = element_text(angle = 45, hjust = 1))  # Inclinaison du texte de l'axe des x pour une meilleure lisibilité
View(heatmap_plot)
heatmap_plot
# Créer la heatmap
heatmap_plot <- ggplot(data = df, aes(x = factor(rownames(df)), y = factor(colnames(df)))) +
geom_tile(aes(fill = df), color = "white") +
scale_fill_gradient(low = "blue", high = "red") +  # Choix des couleurs (ici, utilise une échelle de couleurs)
#labs(x = "Colonnes", y = "Lignes", fill = "Valeurs") +  # Étiquettes des axes et de la légende
theme_minimal() +  # Style du thème (vous pouvez choisir un autre style si vous préférez)
theme(axis.text.x = element_text(angle = 45, hjust = 1))  # Inclinaison du texte de l'axe des x pour une meilleure lisibilité
heatmap_plot
ggplot(data = df, aes(x = factor(rownames(df)), y = factor(colnames(df)))) +
geom_tile(aes(fill = df), color = "white") +
scale_fill_gradient(low = "blue", high = "red") +  # Choix des couleurs (ici, utilise une échelle de couleurs)
#labs(x = "Colonnes", y = "Lignes", fill = "Valeurs") +  # Étiquettes des axes et de la légende
theme_minimal() +  # Style du thème (vous pouvez choisir un autre style si vous préférez)
theme(axis.text.x = element_text(angle = 45, hjust = 1))  # Inclinaison du texte de l'axe des x pour une meilleure lisibilité
# Transformer le dataframe en un format de tableau (matrice)
data_matrix <- reshape2::dcast(df, Lignes ~ Colonnes, value.var = "Valeurs")
# Votre dataframe (remplacez 'df' par votre propre dataframe)
df <- data.frame(
Lignes = c("A", "B", "C"),
Colonnes = c("X", "Y", "Z"),
Valeurs = c(1, 2, 3, 4, 5, 6, 7, 8, 9)
)
View(df)
# Votre dataframe (remplacez 'df' par votre propre dataframe)
# Exemple de dataframe
df <- data.frame(
Lignes = c("A", "B", "C"),
Colonne1 = c(10, 20, 30),
Colonne2 = c(15, 25, 35),
Colonne3 = c(5, 10, 15)
)
View(df)
# Charger la bibliothèque
library(ggplot2)
# Créer la heatmap
heatmap_plot <- ggplot(data = df, aes(x = Lignes, y = Colonne)) +
geom_tile(aes(fill = Colonne1), color = "white") +
scale_fill_gradient(low = "blue", high = "red") +
labs(x = "Lignes", y = "Colonnes", fill = "Valeurs") +
theme_minimal() +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
print(heatmap_plot)
# Votre dataframe
df <- data.frame(
Lignes = c("A", "B", "C"),
Colonne1 = c(10, 20, 30),
Colonne2 = c(15, 25, 35),
Colonne3 = c(5, 10, 15)
)
# Transformer le dataframe en un format de tableau (matrice)
data_matrix <- as.matrix(df[, -1])  # Exclure la colonne "Lignes" pour obtenir les valeurs numériques
# Créer la heatmap
heatmap_plot <- ggplot(data = df, aes(x = Lignes, y = colnames(data_matrix))) +
geom_tile(aes(fill = data_matrix), color = "white") +
scale_fill_gradient(low = "blue", high = "red") +
labs(x = "Lignes", y = "Colonnes", fill = "Valeurs") +
theme_minimal() +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
print(heatmap_plot)
library(reshape2)
# Votre dataframe
df <- data.frame(
Lignes = c("A", "B", "C"),
Colonne1 = c(10, 20, 30),
Colonne2 = c(15, 25, 35),
Colonne3 = c(5, 10, 15)
)
# Transformer le dataframe en un format de tableau (matrice)
data_matrix <- as.matrix(df[, -1])  # Exclure la colonne "Lignes" pour obtenir les valeurs numériques
# Convertir la matrice en format long (melt)
melted_df <- melt(data_matrix)
# Créer la heatmap
heatmap_plot <- ggplot(data = melted_df, aes(x = Lignes, y = variable, fill = value)) +
geom_tile(color = "white") +
scale_fill_gradient(low = "blue", high = "red") +
labs(x = "Lignes", y = "Colonnes", fill = "Valeurs") +
theme_minimal() +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
print(heatmap_plot)
# Créer la heatmap
heatmap_plot <- ggplot(data = melted_df, aes(x = Lignes, y = variable, fill = value)) +
geom_tile(color = "white") +
scale_fill_gradient(low = "blue", high = "red") +
#labs(x = "Lignes", y = "Colonnes", fill = "Valeurs") +
theme_minimal() +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
print(heatmap_plot)
View(data_matrix)
# Créer la heatmap
heatmap_plot <- ggplot(data = melted_df, aes(x = row.names(), y = variable, fill = value)) +
geom_tile(color = "white") +
scale_fill_gradient(low = "blue", high = "red") +
#labs(x = "Lignes", y = "Colonnes", fill = "Valeurs") +
theme_minimal() +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
print(heatmap_plot)
# Créer la heatmap
heatmap_plot <- ggplot(data = melted_df, aes(x = Lignes, y = variable, fill = value)) +
geom_tile(color = "white") +
scale_fill_gradient(low = "blue", high = "red") +
#labs(x = "Lignes", y = "Colonnes", fill = "Valeurs") +
theme_minimal() +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
print(heatmap_plot)
# Créer la heatmap
heatmap_plot <- ggplot(data = df, aes(x = Colonne1:Colonne3)) +
geom_tile(aes(fill = as.matrix(data_matrix)), color = "white") +
scale_fill_gradient(low = "blue", high = "red") +
labs(x = "Colonnes", fill = "Valeurs") +
theme_minimal() +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
print(heatmap_plot)
raisons_ratio <- read_excel("~/Documents/Pubpeer Gender/raisons_ratio.xlsx")
row.names(raisons_ratio) <- raisons_ratio$`Reasons (Retraction Watch)`
df <- raisons_ratio %>%
subset(., select = -`Reasons (Retraction Watch)`, drop = FALSE)
row.names(df) <- raisons_ratio$`Reasons (Retraction Watch)`
View(df)
install.packages("pheatmap")
library("pheatmap")
pheatmap(df)
View(raisons_ratio)
pheatmap(df, kmeans_k = 4)
pheatmap(df, cutree_rows = 4, cutree_cols = 3)
# Transformer les valeurs dans le dataframe selon les conditions spécifiées
df_transformed <- df %>%
mutate_all(function(x) {
case_when(
x <= 0.5 ~ 0.5,
x > 0.5 & x <= 0.8 ~ 0.8,
x > 0.8 & x <= 1.1 ~ 1.1,
x > 1.1 & x <= 1.4 ~ 1.4,
x > 1.4 & x <= 1.9 ~ 1.9,
x > 2 ~ 2,
TRUE ~ x  # Pour conserver les autres valeurs telles quelles
)
})
print(df_transformed)
View(df_transformed)
pheatmap(df_transformed)
row.names(df_transformed) <- raisons_ratio$`Reasons (Retraction Watch)`
pheatmap(df_transformed)
pheatmap(df_transformed, kmeans_k = 4)
pheatmap(df_transformed, cutree_rows = 4, cutree_cols = 3)
pheatmap(df_transformed, cutree_rows = 4)
pheatmap(df_transformed, cutree_rows = 5, cutree_cols = 3)
pheatmap(df_transformed, cutree_rows = 5, cutree_cols = 4)
pheatmap(df_transformed, cutree_rows = 4, cutree_cols = 4)
pheatmap(df_transformed, cutree_rows = 5, cutree_cols = 4)
# Transformer les valeurs dans le dataframe selon les conditions spécifiées
df_transformed <- df %>%
mutate_all(function(x) {
case_when(
x <= 0.3 ~ 0.3,
x > 0.3 & x <= 0.5 ~ 0.5,
x > 0.5 & x <= 0.7 ~ 0.7,
x > 0.7 & x <= 0.9 ~ 0.9,
x > 0.9 & x <= 1.1 ~ 1.1,
x > 1.1 & x <= 1.3 ~ 1.3,
x > 1.3 & x <= 1.5 ~ 1.5,
x > 1.5 & x <= 1.7 ~ 1.7,
x > 1.7 & x <= 1.9 ~ 1.9,
x > 1.9 & x <= 2.1 ~ 2.1,
x > 2.1 & x <= 2.3 ~ 2.3,
x > 2.3 & x <= 2.5 ~ 2.5,
x > 2.5 ~ 2.5,
TRUE ~ x  # Pour conserver les autres valeurs telles quelles
)
})
row.names(df_transformed) <- raisons_ratio$`Reasons (Retraction Watch)`
pheatmap(df_transformed)
pheatmap(df_transformed, cutree_rows = 5, cutree_cols = 4)
pheatmap(df_transformed, cutree_rows = 4, cutree_cols = 3)
case_when(
x <= 0.3 ~ 0.3,
x > 0.3 & x <= 0.5 ~ 0.5,
x > 0.5 & x <= 0.7 ~ 0.7,
x > 0.7 & x <= 0.9 ~ 0.9,
x > 0.9 & x <= 1.1 ~ 1.1,
x > 1.1 & x <= 1.3 ~ 1.3,
x > 1.3 & x <= 1.5 ~ 1.5,
x > 1.5 & x <= 1.7 ~ 1.7,
x > 1.7 & x <= 1.9 ~ 1.9,
x > 1.9 & x <= 2.1 ~ 2.1,
x > 2.1 & x <= 2.3 ~ 2.3,
x > 2.3 & x <= 2.5 ~ 2.5,
x > 2.5 & x <= 2.7 ~ 2.7,
x > 2.7 & x <= 2.9 ~ 2.9,
x > 2.9 ~ 2.9,
TRUE ~ x  # Pour conserver les autres valeurs telles quelles
)
# Transformer les valeurs dans le dataframe selon les conditions spécifiées
df_transformed <- df %>%
mutate_all(function(x) {
case_when(
x <= 0.3 ~ 0.3,
x > 0.3 & x <= 0.5 ~ 0.5,
x > 0.5 & x <= 0.7 ~ 0.7,
x > 0.7 & x <= 0.9 ~ 0.9,
x > 0.9 & x <= 1.1 ~ 1.1,
x > 1.1 & x <= 1.3 ~ 1.3,
x > 1.3 & x <= 1.5 ~ 1.5,
x > 1.5 & x <= 1.7 ~ 1.7,
x > 1.7 & x <= 1.9 ~ 1.9,
x > 1.9 & x <= 2.1 ~ 2.1,
x > 2.1 & x <= 2.3 ~ 2.3,
x > 2.3 & x <= 2.5 ~ 2.5,
x > 2.5 & x <= 2.7 ~ 2.7,
x > 2.7 & x <= 2.9 ~ 2.9,
x > 2.9 ~ 2.9,
TRUE ~ x  # Pour conserver les autres valeurs telles quelles
)
})
row.names(df_transformed) <- raisons_ratio$`Reasons (Retraction Watch)`
pheatmap(df_transformed)
pheatmap(df_transformed, kmeans_k = 4)
pheatmap(df_transformed, cutree_rows = 4)
pheatmap(df_transformed, cutree_rows = 4, cutree_cols = 3)
pheatmap(df_transformed, cutree_rows = 5, cutree_cols = 4)
load("D:/Pubpeer/mon_espace_de_travail.RData")
>>>>>>> c7416576a75b4badd60689b3e24130bae8f13e4c
