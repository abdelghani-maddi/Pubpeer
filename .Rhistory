relative_prop <- as.data.frame(prop_retracted / prop_all)
# Print the resulting table of relative proportions
relative_prop
## représentation graphique
ggplot(relative_prop, aes(x = reorder(Var1, Freq), y = Freq)) +
geom_bar(stat = "identity") +
geom_col(fill = "#2C81C9") +
labs(
x = "Men-women collaboration type",
y = "% in retracted / % in overall"
) +
coord_flip() +
theme_light()
df_retract <- read_excel("/Users/maddi/Documents/Pubpeer Gender/df_gender_retract2.xlsx") ## bdd sur le genre + bdd retractations (version avril 2023)
#write.xlsx(df_retract, "/Users/maddi/Documents/Pubpeer Gender/df_retract.xlsx")
reason_agr <- read_excel("~/Documents/Pubpeer Gender/reasons_retract aggreg.xlsx")
# dupliquer la colonne Gtype en Gtype2, en modifiant les modalités selon ces conditions :
# pour les valeurs de Gtype différentes de : ("Woman alone", "Man alone", "Collab. men only", "Collab. women only"),
# si w_corresp=1, Gtype2="Collab. men-women . w corr", si m_corresp=1, Gtype2="Collab. men-women . m corr"
# Ajouter le flag femme auteur de correspondance (proxy : 1er auteur)
df_retract <- df_retract %>%
mutate(w_corresp = ifelse(order_auteur == 1 & g_prob_06 == "female", 1, 0))
# Ajouter le flag homme auteur de correspondance (proxy : 1er auteur)
df_retract <- df_retract %>%
mutate(m_corresp = ifelse(order_auteur == 1 & g_prob_06 == "male", 1, 0))
##
df_retract <- df_retract %>%
mutate(Gtype2 = case_when(
Gtype %in% c("Woman alone", "Man alone", "Collab. men only", "Collab. women only") ~ Gtype,
w_corresp == 1 ~ "Collab. men-women . w corr",
m_corresp == 1 ~ "Collab. men-women . m corr",
TRUE ~ Gtype
))
df_retract_agr %>%
tbl_summary(
include = c(reason_aggreg, Gtype2),
by = Gtype2,
sort = list(everything() ~ "frequency"),
statistic = list(
all_continuous() ~ c("{N_obs}")
)
) %>%
add_overall(last = TRUE) #, col_label = "**Ensemble** (effectif total: {N})")
df %>%
tbl_summary(
include = c(publication, Gtype2, is_retracted),
by = is_retracted,
sort = list(everything() ~ "frequency"),
statistic = list(
all_continuous() ~ c("{N_obs}")
)
) %>%
add_overall()  %>%
# adding spanning header
modify_spanning_header(c("stat_1", "stat_2") ~ "**Is retracted**") %>%
add_p() %>%
separate_p_footnotes()
######
df <- df_retract %>%
select(publication, Gtype2, is_retracted) %>%
unique()
df %>%
tbl_summary(
include = c(publication, Gtype2, is_retracted),
by = is_retracted,
sort = list(everything() ~ "frequency"),
statistic = list(
all_continuous() ~ c("{N_obs}")
)
) %>%
add_overall()  %>%
# adding spanning header
modify_spanning_header(c("stat_1", "stat_2") ~ "**Is retracted**") %>%
add_p() %>%
separate_p_footnotes()
View(df)
df_retract <- df_retract %>%
select(publication, Gtype2, ID_retractionwatch, Reason) %>%
unique()
# Merger les deux pour avoir les raisons aggrégées
df_retract_agr <- merge(df_retract, reason_agr, by = "Reason")
df_retract_agr %>%
tbl_summary(
include = c(reason_aggreg, Gtype2),
by = Gtype2,
sort = list(everything() ~ "frequency"),
statistic = list(
all_continuous() ~ c("{N_obs}")
)
) %>%
add_overall(last = TRUE) #, col_label = "**Ensemble** (effectif total: {N})")
######
df <- df_retract %>%
select(publication, Gtype2, is_retracted) %>%
unique()
df_retract_agr %>%
tbl_summary(
include = c(reason_aggreg, Gtype2),
by = Gtype2,
sort = list(everything() ~ "frequency"),
statistic = list(
all_continuous() ~ c("{N_obs}")
)
) %>%
add_overall(last = TRUE) #, col_label = "**Ensemble** (effectif total: {N})")
df_retract <- read_excel("/Users/maddi/Documents/Pubpeer Gender/df_gender_retract2.xlsx") ## bdd sur le genre + bdd retractations (version avril 2023)
##
df_retract <- df_retract %>%
mutate(Gtype2 = case_when(
Gtype %in% c("Woman alone", "Man alone", "Collab. men only", "Collab. women only") ~ Gtype,
w_corresp == 1 ~ "Collab. men-women . w corr",
m_corresp == 1 ~ "Collab. men-women . m corr",
TRUE ~ Gtype
))
# dupliquer la colonne Gtype en Gtype2, en modifiant les modalités selon ces conditions :
# pour les valeurs de Gtype différentes de : ("Woman alone", "Man alone", "Collab. men only", "Collab. women only"),
# si w_corresp=1, Gtype2="Collab. men-women . w corr", si m_corresp=1, Gtype2="Collab. men-women . m corr"
# Ajouter le flag femme auteur de correspondance (proxy : 1er auteur)
df_retract <- df_retract %>%
mutate(w_corresp = ifelse(order_auteur == 1 & g_prob_06 == "female", 1, 0))
# Ajouter le flag homme auteur de correspondance (proxy : 1er auteur)
df_retract <- df_retract %>%
mutate(m_corresp = ifelse(order_auteur == 1 & g_prob_06 == "male", 1, 0))
##
df_retract <- df_retract %>%
mutate(Gtype2 = case_when(
Gtype %in% c("Woman alone", "Man alone", "Collab. men only", "Collab. women only") ~ Gtype,
w_corresp == 1 ~ "Collab. men-women . w corr",
m_corresp == 1 ~ "Collab. men-women . m corr",
TRUE ~ Gtype
))
## supprimer toutes les lignes pour lesquelles w_corresp et m_corresp = 0
df_retract <- df_retract %>%
filter(w_corresp != 0 | m_corresp != 0)
## décortiquer les raisons
# éclater les raisons
df_retract_reason <- df_retract %>%
separate_rows(Reason, sep = ";")%>%
filter(Reason != "") %>%
mutate(Reason = str_replace(Reason, "\\+", ""))
# calcul de la fréquence
freq_reasons <- freq(df_retract$Reason) %>%
data_frame(rownames(.), .)
df_retract <- df_retract %>%
select(publication, Gtype2, ID_retractionwatch, Reason) %>%
unique()
# Merger les deux pour avoir les raisons aggrégées
df_retract_agr <- merge(df_retract, reason_agr, by = "Reason")
df_retract_agr %>%
tbl_summary(
include = c(reason_aggreg, Gtype2),
by = Gtype2,
sort = list(everything() ~ "frequency"),
statistic = list(
all_continuous() ~ c("{N_obs}")
)
) %>%
add_overall(last = TRUE) #, col_label = "**Ensemble** (effectif total: {N})")
# Merger les deux pour avoir les raisons aggrégées
df_retract_agr <- merge(df_retract, reason_agr, by = "Reason")
# coocuurences des raisons (pour aider à l'interprétation)
# Calculer les co-occurrences des raisons
df_cooccurrences <- df_retract_agr %>%
select(publication, reason_aggreg) %>%
unique() %>%
inner_join(df_retract_agr, by = "publication") %>%
filter(reason_aggreg.x != reason_aggreg.y) %>%
group_by(reason_aggreg.x, reason_aggreg.y) %>%
summarise(nb_publication = n()) %>%
ungroup()
# Renommer les colonnes
colnames(df_cooccurrences) <- c("Reason_1", "Reason_2", "nb_publication")
df_retract_agr %>%
tbl_summary(
include = c(reason_aggreg, Gtype2),
by = Gtype2,
sort = list(everything() ~ "frequency"),
statistic = list(
all_continuous() ~ c("{N_obs}")
)
) %>%
add_overall(last = TRUE) #, col_label = "**Ensemble** (effectif total: {N})")
reason_agreg <- df_retract_agr %>%
select(reason_aggreg, Gtype2) %>%
table() %>%
data.frame()
df_retract_agr %>%
tbl_summary(
include = c(reason_aggreg, Gtype2),
by = Gtype2,
sort = list(everything() ~ "frequency"),
statistic = list(
all_continuous() ~ c("{N_obs}")
)
) %>%
add_overall(last = TRUE) #, col_label = "**Ensemble** (effectif total: {N})")
df_retract <- df_retract %>%
select(publication, Gtype2, ID_retractionwatch, Reason) %>%
unique()
# Merger les deux pour avoir les raisons aggrégées
df_retract_agr <- merge(df_retract, reason_agr, by = "Reason")
df_retract_agr %>%
tbl_summary(
include = c(reason_aggreg, Gtype2),
by = Gtype2,
sort = list(everything() ~ "frequency"),
statistic = list(
all_continuous() ~ c("{N_obs}")
)
) %>%
add_overall(last = TRUE) #, col_label = "**Ensemble** (effectif total: {N})")
######
df <- df_retract %>%
select(publication, Gtype2, is_retracted) %>%
unique()
# dupliquer la colonne Gtype en Gtype2, en modifiant les modalités selon ces conditions :
# pour les valeurs de Gtype différentes de : ("Woman alone", "Man alone", "Collab. men only", "Collab. women only"),
# si w_corresp=1, Gtype2="Collab. men-women . w corr", si m_corresp=1, Gtype2="Collab. men-women . m corr"
# Ajouter le flag femme auteur de correspondance (proxy : 1er auteur)
df_retract <- df_retract %>%
mutate(w_corresp = ifelse(order_auteur == 1 & g_prob_06 == "female", 1, 0))
# Ajouter le flag homme auteur de correspondance (proxy : 1er auteur)
df_retract <- df_retract %>%
mutate(m_corresp = ifelse(order_auteur == 1 & g_prob_06 == "male", 1, 0))
##
df_retract <- df_retract %>%
mutate(Gtype2 = case_when(
Gtype %in% c("Woman alone", "Man alone", "Collab. men only", "Collab. women only") ~ Gtype,
w_corresp == 1 ~ "Collab. men-women . w corr",
m_corresp == 1 ~ "Collab. men-women . m corr",
TRUE ~ Gtype
))
## supprimer toutes les lignes pour lesquelles w_corresp et m_corresp = 0
df_retract <- df_retract %>%
filter(w_corresp != 0 | m_corresp != 0)
df_retract <- read_excel("/Users/maddi/Documents/Pubpeer Gender/df_gender_retract2.xlsx") ## bdd sur le genre + bdd retractations (version avril 2023)
# dupliquer la colonne Gtype en Gtype2, en modifiant les modalités selon ces conditions :
# pour les valeurs de Gtype différentes de : ("Woman alone", "Man alone", "Collab. men only", "Collab. women only"),
# si w_corresp=1, Gtype2="Collab. men-women . w corr", si m_corresp=1, Gtype2="Collab. men-women . m corr"
# Ajouter le flag femme auteur de correspondance (proxy : 1er auteur)
df_retract <- df_retract %>%
mutate(w_corresp = ifelse(order_auteur == 1 & g_prob_06 == "female", 1, 0))
# Ajouter le flag homme auteur de correspondance (proxy : 1er auteur)
df_retract <- df_retract %>%
mutate(m_corresp = ifelse(order_auteur == 1 & g_prob_06 == "male", 1, 0))
##
df_retract <- df_retract %>%
mutate(Gtype2 = case_when(
Gtype %in% c("Woman alone", "Man alone", "Collab. men only", "Collab. women only") ~ Gtype,
w_corresp == 1 ~ "Collab. men-women . w corr",
m_corresp == 1 ~ "Collab. men-women . m corr",
TRUE ~ Gtype
))
df_retract <- df_retract %>%
select(publication, Gtype2, ID_retractionwatch, Reason) %>%
unique()
df_retract <- read_excel("/Users/maddi/Documents/Pubpeer Gender/df_gender_retract2.xlsx") ## bdd sur le genre + bdd retractations (version avril 2023)
# dupliquer la colonne Gtype en Gtype2, en modifiant les modalités selon ces conditions :
# pour les valeurs de Gtype différentes de : ("Woman alone", "Man alone", "Collab. men only", "Collab. women only"),
# si w_corresp=1, Gtype2="Collab. men-women . w corr", si m_corresp=1, Gtype2="Collab. men-women . m corr"
# Ajouter le flag femme auteur de correspondance (proxy : 1er auteur)
df_retract <- df_retract %>%
mutate(w_corresp = ifelse(order_auteur == 1 & g_prob_06 == "female", 1, 0))
# Ajouter le flag homme auteur de correspondance (proxy : 1er auteur)
df_retract <- df_retract %>%
mutate(m_corresp = ifelse(order_auteur == 1 & g_prob_06 == "male", 1, 0))
##
df_retract <- df_retract %>%
mutate(Gtype2 = case_when(
Gtype %in% c("Woman alone", "Man alone", "Collab. men only", "Collab. women only") ~ Gtype,
w_corresp == 1 ~ "Collab. men-women . w corr",
m_corresp == 1 ~ "Collab. men-women . m corr",
TRUE ~ Gtype
))
## supprimer toutes les lignes pour lesquelles w_corresp et m_corresp = 0
df_retract <- df_retract %>%
filter(w_corresp != 0 | m_corresp != 0)
######
df <- df_retract %>%
select(publication, Gtype2, is_retracted) %>%
unique()
df %>%
tbl_summary(
include = c(publication, Gtype2, is_retracted),
by = is_retracted,
sort = list(everything() ~ "frequency"),
statistic = list(
all_continuous() ~ c("{N_obs}")
)
) %>%
add_overall()  %>%
# adding spanning header
modify_spanning_header(c("stat_1", "stat_2") ~ "**Is retracted**") %>%
add_p() %>%
separate_p_footnotes()
# Calculate the total number of rows in the dataframe
total <- nrow(df)
# Create a table of counts for each "Gtype" value
table_all <- table(df$Gtype2)
# Create a table of counts for each "Gtype" value where "Retracted" is "True"
table_retracted <- table(df$Gtype2[df$is_retracted == 1])
# Calculate the relative proportion of each "Gtype" value in the entire dataframe
prop_all <- table_all / total
# Calculate the relative proportion of each "Gtype" value for "Retracted" = TRUE
prop_retracted <- table_retracted / sum(df$is_retracted == 1)
# Divide the relative proportions for "Retracted" = TRUE by those in the entire dataframe
relative_prop <- as.data.frame(prop_retracted / prop_all)
# Print the resulting table of relative proportions
relative_prop
View(df_gender)
df_nb_aut %>%
select(publication, Gtype) %>%
unique()
# write.xlsx(
rm(list = ls()) #supprimer tous les objets
library(tidyverse)
library(questionr)
library(RPostgres)
library(gtsummary)
library(openxlsx2)
library(gender)
library(GenderInfer)
library(genderizeR)
library(openxlsx)
data_pub = read.csv2('/Users/maddi/Documents/Pubpeer project/Donnees/Bases PubPeer/PubPeer_Base publications.csv', sep=";")
data_comm = dbGetQuery(con,reqsql)
# Connexion ----
con<-dbConnect(RPostgres::Postgres())
db <- 'SKEPTISCIENCE'  #provide the name of your db
host_db <- 'localhost' # server
db_port <- '5433'  # port DBA
db_user <- 'postgres' # nom utilisateur
db_password <- '********'
con <- dbConnect(RPostgres::Postgres(), dbname = db, host=host_db, port=db_port, user=db_user, password=db_password)
db_password <- 'Maroua1912'
con <- dbConnect(RPostgres::Postgres(), dbname = db, host=host_db, port=db_port, user=db_user, password=db_password)
# Test connexion
dbListTables(con)
data_comm = dbGetQuery(con,reqsql)
reqsql= paste('select inner_id, publication, "DateCreated" as date_com, html as comm from data_commentaires_2')
data_comm = dbGetQuery(con,reqsql)
rtw <- readxl::read_excel("~/Documents/Pubpeer project/Pubpeer explo/Gender/RWDBDNLD04242023.xlsx",sheet = "RWDBDNLD04242023")
### Extraction colonnes d'intérêt et suppression des autres données
df <- data_pub %>%
select(publication, Auteurs, Pays_institution, Nombre.de.commentaires, Année, starts_with("Journal"))
### Extraction colonnes d'intérêt et suppression des autres données
df <- bdd_pub %>%
select(publication, Auteurs, Pays_institution, `Nombre de commentaires`, Année, starts_with("Journal"))
# Pivoter les noms des auteurs par autant de lignes que d'auteurs et dupliquer l'identifiant "publication"
df_unnested <- df %>%
mutate(prenoms = str_extract_all(Auteurs, "(?<=')[A-Za-z]+")) %>%
unnest(prenoms) %>%
select(-Auteurs)
givenNames <- read_excel("~/Documents/Pubpeer Gender/gender_proba.xlsx")
# ajouter une colonne ordre des auteurs
df_unnested <- df_unnested %>%
group_by(publication) %>%
mutate(order_auteur = row_number())
df_final <- merge(df_unnested, givenNames, by.x = "prenoms", by.y = "given_name", all.x = TRUE) # matcher
# aJOUTER UNE COLONNE POUR INDIQUER SI LES FEMMES SE TROUVENT EN PREMIERE OU DERNIERE POSITION
df_final <- df_final %>%
group_by(publication) %>%
mutate(woman_leader = case_when(
gender == "female" & proba >= 0.6 & (order_auteur == min(order_auteur) | order_auteur == max(order_auteur)) ~ 1,
TRUE ~ 0
))
df_final <- df_final %>%
group_by(publication) %>%
mutate(woman_leader = ifelse(any(woman_leader == 1), 1, woman_leader))
# stats desc juste pour vérif
df_test <- df_final %>%
select(publication, woman_leader) %>%
unique()
# Définir une fonction pour remplacer les valeurs manquantes selon les conditions données
replace_missing_values <- function(df, column) {
df[column][is.na(df[column]) & nchar(df$prenoms) <= 2] <- "initials"
df[column][is.na(df[column]) & !(nchar(df$prenoms) <= 2)] <- "undefined"
df[column][is.na(df[column])] <- "undefined"
return(df)
}
# Modifier les colonnes spécifiées en fonction des conditions
df_final <- transform(df_final, g_prob_06 = gender, g_prob_07 = gender, g_prob_08 = gender, g_prob_09 = gender, g_prob_100 = gender)
df_final$g_prob_06[df_final$proba < 0.6] <- "unisex"
df_final <- replace_missing_values(df_final, "g_prob_06")
df_final$g_prob_07[df_final$proba < 0.7] <- "unisex"
df_final <- replace_missing_values(df_final, "g_prob_07")
df_final$g_prob_08[df_final$proba < 0.8] <- "unisex"
df_final <- replace_missing_values(df_final, "g_prob_08")
df_final$g_prob_09[df_final$proba < 0.9] <- "unisex"
df_final <- replace_missing_values(df_final, "g_prob_09")
df_final$g_prob_100[df_final$proba >= 0.5 & df_final$proba < 0.99] <- "unisex"
df_final <- replace_missing_values(df_final, "g_prob_100")
df_final <- replace_missing_values(df_final, "gender")
View(df_final)
# Compter le nombre d'auteurs par publication
nbaut <- df_final %>%
group_by(publication) %>%
summarise(nb_aut = n_distinct(prenoms))
# Ajouter à la table des publications
df_nb_aut <- merge(df_final, nbaut, by.x = "publication", by.y = "publication", all.x = TRUE) # matcher
df_nb_aut <- tb_finale_gender
# stats desc proba et genre
df_nb_aut %>%
tbl_summary(
include = c("proba", "g_prob_06", "g_prob_07", "g_prob_08", "g_prob_09", "g_prob_100")
)
View(df_final)
describe(df_final$proba)
look_for(df_final$proba)
table(df_final$proba)
# stats desc proba et genre
df_final %>%
tbl_summary(
include = c("proba", "g_prob_06", "g_prob_07", "g_prob_08", "g_prob_09", "g_prob_100")
)
View(df_final)
# matcher les prénoms
df_unnested$prenoms <- tolower(df_unnested$prenoms) # mettre en minuscules
givenNames <- givenNames %>% # extraire valeurs uniques
unique()
df_final <- merge(df_unnested, givenNames, by.x = "prenoms", by.y = "given_name", all.x = TRUE) # matcher
View(df_final)
# aJOUTER UNE COLONNE POUR INDIQUER SI LES FEMMES SE TROUVENT EN PREMIERE OU DERNIERE POSITION
df_final <- df_final %>%
group_by(publication) %>%
mutate(woman_leader = case_when(
gender == "female" & proba >= 0.6 & (order_auteur == min(order_auteur) | order_auteur == max(order_auteur)) ~ 1,
TRUE ~ 0
))
# matcher les prénoms
df_unnested$prenoms <- tolower(df_unnested$prenoms) # mettre en minuscules
givenNames <- givenNames %>% # extraire valeurs uniques
unique()
# ajouter une colonne ordre des auteurs
df_unnested <- df_unnested %>%
group_by(publication) %>%
mutate(order_auteur = row_number())
df_final <- merge(df_unnested, givenNames, by.x = "prenoms", by.y = "given_name", all.x = TRUE) # matcher
# df_final$gender[df_final$proba < 0.6] <- "unisex" # modifier les probas < 0.6 à Unisexe
# aJOUTER UNE COLONNE POUR INDIQUER SI LES FEMMES SE TROUVENT EN PREMIERE OU DERNIERE POSITION
df_final <- df_final %>%
group_by(publication) %>%
mutate(woman_leader = case_when(
gender == "female" & proba >= 0.6 & (order_auteur == min(order_auteur) | order_auteur == max(order_auteur)) ~ 1,
TRUE ~ 0
))
df_final$gender[df_final$proba < 0.6] <- "unisex" # modifier les probas < 0.6 à Unisexe
df_final <- merge(df_unnested, givenNames, by.x = "prenoms", by.y = "given_name", all.x = TRUE) # matcher
# ajouter une colonne ordre des auteurs
df_unnested <- df_unnested %>%
group_by(publication) %>%
mutate(order_auteur = row_number())
df_final <- merge(df_unnested, givenNames, by.x = "prenoms", by.y = "given_name", all.x = TRUE) # matcher
View(givenNames)
View(df_unnested)
df_final <- merge(df_unnested, givenNames, by.x = "prenoms", by.y = "given_name", all.x = TRUE) # matcher
rm(list = ls()) #supprimer tous les objets
# https://store.genderize.io/usage
# https://github.com/kalimu/genderizeR/issues/7
# https://genderize.io/
# https://journal.r-project.org/archive/2016/RJ-2016-002/index.html
# https://kalimu.github.io/#contact
# devtools::install_github("kalimu/genderizeR")
library(tidyverse)
library(questionr)
library(RPostgres)
library(gtsummary)
library(openxlsx2)
library(gender)
library(GenderInfer)
library(genderizeR)
#library(genderizeR)
library(openxlsx)
# Connexion ----
con<-dbConnect(RPostgres::Postgres())
db <- 'SKEPTISCIENCE'  #provide the name of your db
host_db <- 'localhost' # server
db_port <- '5433'  # port DBA
db_user <- 'postgres' # nom utilisateur
db_password <- '*********'
con <- dbConnect(RPostgres::Postgres(), dbname = db, host=host_db, port=db_port, user=db_user, password=db_password)
con<-dbConnect(RPostgres::Postgres())
db <- 'SKEPTISCIENCE'  #provide the name of your db
host_db <- 'localhost' # server
db_port <- '5433'  # port DBA
db_user <- 'postgres' # nom utilisateur
db_password <- 'Maroua1912'
con <- dbConnect(RPostgres::Postgres(), dbname = db, host=host_db, port=db_port, user=db_user, password=db_password)
# Test connexion
dbListTables(con)
### Récupération des données ----
reqsql= paste('select inner_id, publication, "DateCreated" as date_com, html as comm from data_commentaires_2')
data_pub = read.csv2('/Users/maddi/Documents/Pubpeer project/Donnees/Bases PubPeer/PubPeer_Base publications.csv', sep=";")
data_comm = dbGetQuery(con,reqsql)
rtw <- readxl::read_excel("~/Documents/Pubpeer project/Pubpeer explo/Gender/RWDBDNLD04242023.xlsx",sheet = "RWDBDNLD04242023")
### Extraction colonnes d'intérêt et suppression des autres données
df <- data_pub %>%
select(publication, Auteurs, Pays_institution, Nombre.de.commentaires, Année, starts_with("Journal"))
### Extraction colonnes d'intérêt et suppression des autres données
df <- bdd_pub %>%
select(publication, Auteurs, Pays_institution, `Nombre de commentaires`, Année, starts_with("Journal"))
### Supprimer les données
rm(data_pub)
# Pivoter les noms des auteurs par autant de lignes que d'auteurs et dupliquer l'identifiant "publication"
df_unnested <- df %>%
mutate(prenoms = str_extract_all(Auteurs, "(?<=')[A-Za-z]+")) %>%
unnest(prenoms) %>%
select(-Auteurs)
givenNames <- read_excel("D:/bdd/gender_proba.xlsx")
givenNames <- read_excel("~/Documents/Pubpeer Gender/gender_proba.xlsx")
View(givenNames)
givenNames <- read_excel("~/Documents/Pubpeer Gender/gender_proba.xlsx")
